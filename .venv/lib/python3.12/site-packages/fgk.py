"""This is an implementation of the Algorithm FGK with Adaptive Huffman"""
from node import Node


class FGK(object):
    def __init__(self):
        self.NYT = Node(symbol='NYT', weight=0)
        self.root = self.NYT
        self.nodes = [self.NYT]
        self.seen = [None] * 256

    def get_code(self, node):
        code = ""
        while node.parent:
            code = ('0' if node.parent.left == node else '1') + code
            node = node.parent
        return code

    def find_largest_node(self, weight):
        for node in reversed(self.nodes):
            if node.weight == weight:
                return node
        return None

    def swap_nodes(self, n1, n2):
        if n1.parent == n2 or n2.parent == n1:
            return
    
        i1, i2 = self.nodes.index(n1), self.nodes.index(n2)
        self.nodes[i1], self.nodes[i2] = self.nodes[i2], self.nodes[i1]
    
        p1, p2 = n1.parent, n2.parent
        n1.parent, n2.parent = p2, p1
    
        # update parent children
        if p1 is not None:
            if p1.left == n1:
                p1.left = n2
            else:
                p1.right = n2
        else:
            # n1 is root
            self.root = n2
    
        if p2 is not None:
            if p2.left == n2:
                p2.left = n1
            else:
                p2.right = n1
        else:
            # n2 is root
            self.root = n1


    def update_tree(self, node):
        while node:
            largest = self.find_largest_node(node.weight)
            if largest and largest != node and largest != node.parent:
                self.swap_nodes(node, largest)
            node.weight += 1
            node = node.parent

    def insert_node(self, symbol):
        node = self.seen[symbol]
        if node is None:
            # Nuevo símbolo
            new_node = Node(symbol=symbol, weight=1)
            internal = Node(weight=0)
            internal.left = self.NYT
            internal.right = new_node
            internal.parent = self.NYT.parent
            new_node.parent = internal
            self.NYT.parent = internal

            if internal.parent is None:
                self.root = internal
            else:
                if internal.parent.left == self.NYT:
                    internal.parent.left = internal
                else:
                    internal.parent.right = internal

            self.nodes.insert(0, internal)
            self.nodes.insert(0, new_node)
            self.seen[symbol] = new_node

            self.update_tree(internal.parent)
        else:
            # Símbolo ya visto
            self.update_tree(node)

    def encode(self, data: bytes) -> str:
        bits = ""
        for b in data:
            if self.seen[b]:
                bits += self.get_code(self.seen[b])
            else:
                bits += self.get_code(self.NYT)
                bits += format(b, '08b')
            self.insert_node(b)
        return bits

    def decode(self, bitstring: str) -> bytes:
        result = []
        i = 0
        node = self.root

        while i < len(bitstring):
            node = self.root
            # recorrer hasta hoja
            while not node.is_leaf():
                if i >= len(bitstring):
                    raise ValueError("Bitstring incompleto")
                node = node.left if bitstring[i] == '0' else node.right
                i += 1

            # Nodo hoja
            if node.symbol == 'NYT':
                if i + 8 > len(bitstring):
                    raise ValueError("Bitstring incompleto para símbolo nuevo")
                byte = int(bitstring[i:i+8], 2)
                i += 8
            else:
                byte = node.symbol

            result.append(byte)
            self.insert_node(byte)

        return bytes(result)